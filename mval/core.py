# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/00_core.ipynb (unless otherwise specified).

__all__ = ['validate_param', 'documented_by']

# Cell
from inspect import getmodule
from typing import List, Tuple, Dict, Union, TypeVar, Optional, Callable
import os
import operator

# Cell
def _check_type(p, p_type):
    """
    subclasses always ok for now.

    Operates on
    -----------

    Union, List, Tuple, Dict

    TypeVar is a generic type that doesn't have .__origin__ so any param who's type is supposed to be
    TypeVar automatically passes.
    """
    if (getmodule(p_type).__name__ == "typing") and (p_type is not TypeVar):

        parent_type = p_type.__origin__
        if parent_type is Tuple:
            if not issubclass(type(p), parent_type):
                raise TypeError("expected type {}, but received {}".format(p_type, type(p)))
            inner_types = p_type.__args__
            if len(inner_types) != len(p):
                raise ValueError(("tuple expected {} elements, but " +
                                  "received {}").format(len(inner_types), len(p)))
            for idx, child in enumerate(p):
                _check_type(child, inner_types[idx])

        if parent_type is List:
            if not issubclass(type(p), parent_type):
                raise TypeError("expected type {}, but received {}".format(p_type, type(p)))
            inner_type = p_type.__args__[0]
            for child in p:
                _check_type(child, inner_type)

        if parent_type is Dict:
            if not issubclass(type(p), parent_type):
                raise TypeError("expected type {}, but received {}".format(p_type, type(p)))
            key_type, value_type = p_type.__args__
            for key in p:
                _check_type(key, key_type)
                _check_type(p[key], value_type)

        if parent_type is Union:
            allowed_types = p_type.__args__
            for atype in allowed_types:
                atype_origin = atype.__origin__ if (getmodule(atype).__name__ == "typing") else atype
                if issubclass(type(p), atype_origin):
                    _check_type(p, atype)
                    break
            else:
                raise TypeError(("expected one of the following types {}, " +
                                 "but received {}").format(allowed_types, type(p)))


    if (getmodule(p_type).__name__ != "typing") and not issubclass(type(p), p_type):
        raise TypeError("expected type {}, but received {}".format(p_type, type(p)))

# Cell
def _check_restrictions(p, p_restrictions, p_type):
    """
    p_restriction can be:
      None >> no restriction
      string >> specialized to represent upper and lower bounds
      set >> contains allowed values

      List[int] >> represents a list of codes for functions to run
      int >> represents a single code for a function

      function >> if it is callable p_restriction(p) is run result should be bool.
      True is good, False is bad
    """
    # "(0,100]", {1,2,3,4,5},

    # p_restriction is a callable function
    if callable(p_restrictions):
        if not p_restrictions(p):
            raise ValueError(("{} doesn't meet the restrictions enforced by " +
                              "function: {}").format(p, p_restrictions))

    # p_restriction is a bounds expression
    elif type(p_restrictions) is str:
        _validate_bounds_expression(p_type, p_restrictions)  # ensure bounds expression is valid
        p = _check_bounds(p, p_restrictions)

    # p_restriction is a set of allowed values
    elif type(p_restrictions) is set:
        if p not in p_restrictions:
            raise ValueError(("{} doesn't meet the restrictions enforced by " +
                              "set of allowed values: {}").format(p, p_restrictions))

    # p_restriction is None (i.e. no restrictions)
    elif p_restrictions is None:
        pass

    # p_restriction is something not recognized
    else:
        raise TypeError(("Bad p_restriction type.  Expected: None, a callable function that " +
                         "returns a bool representing whether the value meets the restrictions, " +
                         "a string representing a bounds expression, or a set of allowed values.  " +
                         "However, received type {}").format(type(p_restrictions)))
    return p

# Cell
def _validate_bounds_expression(value_type: type, expression: str) -> str:
    """
    Check bounds expression string to ensure that it is valid for evaluation.  In order to be a valid
    expression the following must be True:

        1) start must be '(' or '['
        2) end must be ')' or ']'
        3) must contain only one ','
        4) value_type must be either float or int
        4) values other than these must be interpretable as either ints or floats whichever value_type is
        5) if upper or lower bound is open (i.e. to +/- infinity) then it should be preceded / followed by
           a curly bracket
    """

    expression = expression.strip() # strip whitespace from start and end of strip

    # 1) check that start is one of '(' or '['
    if expression[0] != '(' and expression[0] != '[':
        raise ValueError(("Bad Expression: {}\nShould start with either " +
                          "'(' or '['.  \n").format(expression))

    # 2) check that end is one of ')' or ']'
    if expression[-1] != ')' and expression[-1] != ']':
        raise ValueError("Bad Expression: {}\nShould end with either ')' or ']'.  \n".format(expression))

    # 3) check that expression contains only one comma
    if expression.count(',') != 1:
        raise ValueError(("Bad Expression: {}\nShould contain exactly one ',' seperating lower and " +
                          "upper bounds.  \n").format(expression))

    # 4) check that value type is either float or int
    if value_type is not int and value_type is not float:
        raise ValueError(("Bad Expression: {}\nOnly supported for primative types: <int> and " +
                          "<float>, not {}\n").format(expression, value_type))

    # 5) check that expression values are interpretable as value_type
    lower_val, upper_val = expression[1:-1].split(',')
    if lower_val != '':  # empty string represents an open bound
        try:
            value_type(lower_val)
        except ValueError as error:
            raise ValueError(("Bad Expression: {}\nLower bound value is not interpretable " +
                              "as {}.\n").format(expression, value_type))
    if upper_val != '':
        try:
            value_type(upper_val)
        except ValueError as error:
            raise ValueError(("Bad Expression: {}\nUpper bound value is not interpretable " +
                              "as {}.\n").format(expression, value_type))

    # 6) check that given lower_val / upper_val is '' then it must be preceded / followed by '(' / ')'

    if lower_val == '' and expression[0] != '(':
        raise ValueError(("Bad Expression: {}\nLower bound is open, therefore it must be preceded by " +
                          "'(' not '['.\n").format(expression))
    if upper_val == '' and expression[-1] != ')':
        raise ValueError("Bad Expression: {}\nUpper bound is open, therefore it must be followed by " +
                         "')' not ']'.\n".format(expression))

    # if execution reaches this point all tests above are passing
    return expression

# Cell
def _check_bounds(value: Union[int, float], bounds: str) -> Union[int, float]:
    """
    Assumes that the value is the correct type and the bounds have already been validated.

    Check to see that the variable value falls into the bounds represented by value_restrictions.
    value_restrictions is a string of the form: '(lower_bound, upper_bound]'.  A curly bracket means
    everything upto but not including and a square bracket is inclusive.  If a bound is omitted then it is
    treated as open (to infinity) and must be preceded/followed by a curly bracket.  If the value satifies
    the bounds expression then True is returned otherwise False is returned.
    """

    if value is None:
        raise ValueError("Value {} does not fall within the bounds: {}".format(value, bounds))

    lower_bound, upper_bound = bounds.split(',')  # should always only be one ','
    lower_bound, upper_bound = lower_bound.strip(), upper_bound.strip() # strip away any whitespace

    lower_op = operator.gt if lower_bound[0] == '(' else operator.ge
    upper_op = operator.lt if upper_bound[-1] == ')' else operator.le

    lower_val = lower_bound[1:]  # will be an empty string if no value supplied (i.e open bound)
    upper_val = upper_bound[:-1]

    value_type = type(value)

    if lower_val != '':
        # lower_op is going to be operator.ge or operator.gt
        lower_val = value_type(lower_val)
        if not lower_op(value, lower_val):
            raise ValueError("Value {} does not fall within the bounds: {}".format(value, bounds))
    if upper_val != '':
        # upper_op is going to be operator.le or operatory.lt
        upper_val = value_type(upper_val)
        if not upper_op(value, upper_val):
            raise ValueError("Value {} does not fall within the bounds: {}".format(value, bounds))

    # if execution reaches this point value satisfies bounds expression
    return value




# Cell
def validate_param(p, p_type, p_name, p_restrictions=None):
    """
    This function check parameter `p` to ensure it is of type `p_type`.  `p_name` is the variable
    name of `p` and is strictly used in error messages.  `p_restrictions` are the restrictions that
    the `p` must meet.  If the parameter `p` is the correct type and fits the restrictions then it
    is returned otherwise an exception is raised.

    **Parameters**

    `p_type`: can be virtually any type with support for primative types and objects. More complex
    nested structures can be expressed by importing the python typing module and using the typing
    notation for example:
    (List[str] represents a list of strings).

    `p_name`: should be a `str` matching the name of the variable.

    `p_restrictions`: can be any of the following:
          - None (no restriction)
          - set of allowed values
              ex. {1, 33, 44}
          - bounds expression (for int and float values only)
              ex. [1,)   means 1 <= p < infinity
                  [0,10] means 0 <= p <= 10
                  (,10)  means -infinity < p < 10
          - function returning True if satisfies restriction and False otherwise
              ex.
                  os.path.isfile
          - lambda expression

    The bounds restriction and set of allowed values are intended to make readability easier for the user, but ***ANY***
    restriction can be represented as a function and this allows for more complex restrictions to be represented.

    **Return**

    If parameter is valid than it is returned unchanged, otherwise an exception is raised.

    **Limitations**

    - Only supports the following from typing module: List, Tuple, Dict, and Union
    - Only supports Tuple definitions of fixed size (i.e. Tuple[int, float, str] and not Tuple[int, ...])
    - Restrictions are applied to entire value i.e. not nested values. For example:

        ***Given:*** ```validate_param(p, Tuple[str, str, str], "p", {"A", "B", "C"})```

        The user may intend for the inner values of the tuple to be "A", "B" or "C", but instead this will restrict `p` as a
        whole to being "A", "B", or "C".  If we use the following lambda expression as the restriction we can get the desired
        functionality:

        ***Instead Use:*** ```validate_param(p, Tuple[str, str, str], "p", lambda x: all([True if i in {"A", "B", "C"} else
        False for i in x]))```

    **Examples**

    ```python
    # example 1
    from typing import Union, Tuple

    p = validate_param(p, Union[int, float, Tuple[str, str, pd.DataFrame]], "p", None)
    ```
    This indicates that the type must be an int, float or 3 element tuple with the first two values being strings and the
    last a pandas DataFrame.

    ```python
    # example 2
    p = validate_param(p, str, "p", lambda x: os.path.isfile(x) and x.endswith(".wav"))
    ```
    This indicates that the p must be a str representing a file ending in .wav.  Also note the use of lambda expressions as
    the p_restriction.
    """
    # 1) check type
    try:
        _check_type(p, p_type) # recursive function, therefore catch error here for better error msg
    except TypeError as error:
        raise TypeError("{} expected type {}, but received {} of type {}".format(p_name, p_type, p,
                                                                                 type(p))) from error

    # 2) check restriction
    p = _check_restrictions(p, p_restrictions, p_type)
    return p

# Cell
def documented_by(original_doc_func):
    """
    This decorator function allows functions to copy docstrings from other functions.

    **Parameters**

    `original_doc_func`: function from which to copy docstring

    **Return**

    `<class 'function'>`: that copies the doc string of one function to another.

    **Examples**

    ```python
    # example 1
    @documented_by(original_doc_string)
    def has_copied_docstring():
        pass
    ```

    """
    def wrapper(copied_doc_func):
        copied_doc_func.__doc__ = original_doc_func.__doc__
        return copied_doc_func
    return wrapper